### 第二条：理解 JavaScript 的浮点数
+ 整数也是双精度浮点数，对于整数运算，不必担心舍入误差，但是还要担心所有计算只适用于-2^53 ~ 2^53
+ 位运算进行运算比较特殊，需要转换为32位二进制数位进行运算，最后在转化位JavaScript浮点数
```
8 | 1; //9
整数8用32位二进制表示：
0000 0000 0000 0000 0000 0000 0000 1000
整数1用32位二进制表示：
0000 0000 0000 0000 0000 0000 0000 0001
按位或运算计算的结果位：
0000 0000 0000 0000 0000 0000 0000 1001

使用parseInt函数进行验证，前导0可省略，它们不会影响运算结果：
parseInt("1001", 2); //9 

2 ^ 3; //1
0010
0011 => 0001
parseInt("0001", 2); //1 

```
+ 浮点数是不精确的，尽管有64位的精度,浮点数权衡了精度和性能。解决方式是尽可能地采用整数值运算
```
0.1 + 0.2; //0.3000 0000 0000 0000 4
```
例如：实数满足结合律，总是满足(x+y)+z = x+(y+z);
然而对于浮点数来说，并不总是这样。
```
(0.1 + 0.2)+0.3; //0.6000 0000 0000 0001
0.1+(0.2+0.3); // 0.6
```
解决：
将其转换为整数表示
```
(10+20)+30; // 60
10+(20+30); // 60
```

**注意**
+ JavaScript 的数字都是双精度的浮点数
+ JavaScript 中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。
+ 位运算符将数字视为32位的有符号整数
+ 当心浮点运算中的精度陷阱
